package com.vladproduction.ch16_lock_reentrant_lock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.IntStream;

/**A simple multithreaded design for generating even numbers while using a ReentrantLock to prevent race conditions
 * when multiple threads access shared data. Each thread operates independently, generating even numbers in a thread-safe manner.
 * An example to show how tryLock() is working:
 * Unlike lock() which blocks until the lock is acquired, tryLock() makes a single attempt to acquire the lock and immediately returns a boolean result.
 */
public class EvenNumberGeneratorTryLock {
    public static void main(String[] args) {

        EvenNumberGenerator evenNumberGenerator = new EvenNumberGenerator();

        Runnable generatingTask = () -> IntStream.range(0, 100).forEach(i -> System.out.println(evenNumberGenerator.generate()));

        Thread thread1 = new Thread(generatingTask);
        thread1.start();
        Thread thread2 = new Thread(generatingTask);
        thread2.start();
        Thread thread3 = new Thread(generatingTask);
        thread3.start();
    }

    private static final class EvenNumberGenerator{

        private final Lock lock;

        private int previousGenerated;

        public EvenNumberGenerator() {
            this.lock = new ReentrantLock();
            this.previousGenerated = -2;
        }

        public int generate(){
            return lock.tryLock() ? onSuccessAcquiredLock() : onFailedAcquiredLock();
        }

        /**
         * If the lock is successfully acquired (tryLock() returns true), onSuccessAcquiredLock() is called, which:
         * Increments previousGenerated by 2
         * Releases the lock in a finally block
         * */
        private int onSuccessAcquiredLock(){
            try{
                return previousGenerated += 2;
            }finally {
                lock.unlock();
            }
        }

        /**
         * If the lock cannot be acquired (tryLock() returns false), onFailedAcquiredLock() is called, which:
         * Prints a failure message
         * Throws a RuntimeException
         * */
        private int onFailedAcquiredLock(){
            System.out.printf("Thread %s failed to acquire lock.\n", Thread.currentThread().getName());
            throw new RuntimeException();
        }


    }

}
